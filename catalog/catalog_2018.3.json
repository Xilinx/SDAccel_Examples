{
    "name": "sdaccel_examples", 
    "displayName": "", 
    "description": "", 
    "categories": [
        {
            "name": "acceleration", 
            "displayName": "", 
            "description": "", 
            "categories": [], 
            "examples": [
                {
                    "name": "kmeans", 
                    "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                    "description": [
                        "This is OpenCL Based K-Means clustering Implementation for Xilinx FPGA ", 
                        "Devices. K-means clustering is a method of vector quantization, that ", 
                        "is popular for cluster analysis in data mining. K-means clustering ", 
                        "aims to partition n observations into k clusters in which each ", 
                        "observation belongs to the cluster with the nearest mean, serving as", 
                        "a prototype of the cluster.", 
                        "", 
                        "The application sets two compute units by default so that it will fit ", 
                        "all Xilinx Devices. For bigger Xilinx Devices, user can increase the ", 
                        "number of Compute units in Makefile and can get better performance.", 
                        "It is tested upto 6 compute units for ku115 device and got ", 
                        "approximately 6x improvement with respect to single compute units, which ", 
                        "shows that application is more compute bound (not memory bound) and ", 
                        "performance is directly proportional to number of compute units.", 
                        "", 
                        "__Note__: This application is ported from Rodinia", 
                        "", 
                        "(https://www.cs.virginia.edu/~skadron/wiki/rodinia/)", 
                        "", 
                        "__Usage__\n\n ./kmeans -i input_file [-m max_nclusters ] [-n min_nclusters] [-g global_size] [-c golden_file] [options]", 
                        "", 
                        "\t -i filename      : file containing data to be clustered", 
                        "\t -m max_nclusters : maximum number of clusters allowed [default=5]", 
                        "\t -n min_nclusters : minimum number of clusters allowed [default=5]", 
                        "\t -g global_size   : Specify global size [default=1]", 
                        "\t -c golden_file   : Golden File for result comparison", 
                        "\t -b               : input file is in binary format", 
                        "\t -o               : output cluster center coordinates [default=off]"
                    ], 
                    "displayName": "K-Means", 
                    "author": "Xilinx"
                }, 
                {
                    "name": "nearest_neighbor_linear_search", 
                    "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                    "description": [
                        "This is an optimized implementation of a nearest neighbor linear search algorithm targeting execution on a SDAccel supported FPGA acceleration card."
                    ], 
                    "displayName": "Nearest Neighbor Linear Search", 
                    "author": "Xilinx"
                }, 
                {
                    "name": "smithwaterman", 
                    "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                    "description": [
                        "This is an optimized implementation of the smithwaterman algorithm targeting exection on an SDAccel support FPGA acceleration card.", 
                        "", 
                        "The main algorithm characteristics of this application are", 
                        "", 
                        "1. Compute MaxScore", 
                        "2. Systolic array implementation"
                    ], 
                    "displayName": "Smithwaterman Genetic Sequencing Demo", 
                    "author": "Xilinx"
                }
            ]
        }, 
        {
            "name": "getting_started", 
            "displayName": [
                "Getting Started Examples"
            ], 
            "description": [
                "This page contains examples for users who are new to Xilinx SDx OpenCL Flows. The focus of the examples is towards code optimization for Xilinx devices.The table lists various categories of examples in suggested order which users can follow.", 
                "", 
                "", 
                "__Prerequisites__", 
                " - User is familiar with basics of OpenCL flow.", 
                " - User has gone through SDx tutorial and is familiar with basics of tool functionality and terminology."
            ], 
            "categories": [
                {
                    "name": "clk_freq", 
                    "displayName": [
                        "Clock Frequency Optimization Examples"
                    ], 
                    "description": [
                        "Improving Kernel Clock Frequency through Optimized code."
                    ], 
                    "categories": [], 
                    "examples": [
                        {
                            "name": "critical_path_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This example shows a normal coding style which could lead to critical path issue and design will give degraded timing.  Example also contains better coding style which can improve design timing."
                            ], 
                            "displayName": "Critical Path (C)", 
                            "key_concepts": [
                                "Critical Path handling", 
                                "Improve Timing"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "large_loop_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is a CNN (Convolutional Neural Network) based example which mainly focuses on Convolution operation of a CNN network. The goal of this example is to demonstrate a method to overcome kernel design timing failure issue. It also presents the effectiveness of using multiple compute units to improve performance."
                            ], 
                            "displayName": "Clock Frequency ~ Large Loop Count (C)", 
                            "keywords": [
                                "#pragma HLS ARRAY_PARTITION", 
                                "#pragma HLS PIPELINE", 
                                "#pragma HLS INLINE"
                            ], 
                            "key_concepts": [
                                "Clock Frequency", 
                                "Multiple Compute Units", 
                                "Convolutional Neural Networks"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "large_loop_ocl", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is a CNN (Convolutional Neural Network) based example which mainly focuses on Convolution operation of a CNN network. The goal of this example is to demonstrate a method to overcome kernel design timing failure issue. It also presents the effectiveness of using multiple compute units to improve performance."
                            ], 
                            "displayName": "Clock Frequency ~ Large Loop Count (CL) ", 
                            "keywords": [
                                "xcl_array_partition", 
                                "xcl_pipeline_loop", 
                                "always_inline"
                            ], 
                            "key_concepts": [
                                "Clock Frequency", 
                                "Multiple Compute Units", 
                                "Convolutional Neural Networks"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "split_kernel_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is a multi-filter image processing application to showcase effectiveness of Dataflow/Streams usage. This examples is intended to help developers to break down the complex kernels into multiple sub-functions using HLS Dataflow/Streams. It presents a way to concurrently execute multiple functions with better area utilization compared to a complex single kernel implementation. The main objective of this example is to showcase a way to build a optimal FPGA design which achieves maximum frequency with optimal resource utilization and achieves better performance compared to single complex kernel implementations."
                            ], 
                            "displayName": "Large application Splits into Multiple Kernels (C)", 
                            "keywords": [
                                "#pragma HLS DATAFLOW", 
                                "hls::stream", 
                                "#pragma HLS INLINE", 
                                "#pragma HLS ARRAY_PARTITION", 
                                "#pragma HLS PIPELINE"
                            ], 
                            "key_concepts": [
                                "Dataflow", 
                                "Stream"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "split_kernel_ocl", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is a multi-filter image processing application to showcase effectiveness of Dataflow/Streams usage. This examples is intended to help developers to break down the complex kernel into multiple sub-functions using OpenCL Dataflow. It presents a way to concurrently execute multiple functions with better area utilization compared to a complex single kernel implementation. The main objective of this example is to showcase a way to build a optimal FPGA design which achieves maximum frequency with optimal resource utilization and achieves better performance compared to single kernel implementations."
                            ], 
                            "displayName": "Large application Splits into Multiple Kernels(CL)", 
                            "keywords": [
                                "xcl_dataflow", 
                                "xcl_array_partition", 
                                "xcl_pipeline_loop"
                            ], 
                            "key_concepts": [
                                "Dataflow", 
                                "Stream"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "too_many_cu_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is simple example of vector addition to demonstrate effectiveness of using single compute unit with heavy work load to achieve better performance. Bad example uses multiple compute units to achieve good performance but it results in heavy usage of FPGA resources and area due to which design fails timing. Good example uses single compute unit to compute with heavier work load, it helps in less resource utilization and also helps in kernel scalability. To switch between Good/Bad cases use the flag provided in makefile."
                            ], 
                            "displayName": "Clock Frequency ~ Too Many Compute Units (C) ", 
                            "keywords": [
                                "#pragma HLS PIPELINE", 
                                "#pragma HLS ARRAY_PARTITION"
                            ], 
                            "key_concepts": [
                                "Clock Frequency", 
                                "Data Level Parallelism", 
                                "Multiple Compute Units"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "too_many_cu_ocl", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is simple example of vector addition to demonstrate effectiveness of using single compute unit with heavy work load to achieve better performance. Bad example uses multiple compute units to achieve good performance but it results in heavy usage of FPGA resources and area due to which design fails timing. Good example uses single compute unit to compute with heavier work load, it helps in less resource utilization and also helps in kernel scalability. To switch between Good/Bad cases use the flag provided in makefile."
                            ], 
                            "displayName": "Clock Frequency ~ Too Many Compute Units (CL) ", 
                            "keywords": [
                                "xcl_array_partition(complete, 1)", 
                                "xcl_pipeline_loop"
                            ], 
                            "key_concepts": [
                                "Clock Frequency", 
                                "Data Level Parallelism", 
                                "Multiple Compute Units"
                            ], 
                            "author": "Xilinx"
                        }
                    ]
                }, 
                {
                    "name": "cpu_to_fpga", 
                    "displayName": [
                        "CPU to FPGA Examples"
                    ], 
                    "description": [
                        "Labs to showcase the cpu to fpga conversion with kernel optimizations."
                    ], 
                    "categories": [], 
                    "examples": [
                        {
                            "name": "00_cpu", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is a simple example of matrix multiplication (Row x Col)."
                            ], 
                            "displayName": "00 Matrix Multiplication", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "01_kernel_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is a simple example of HLS matrix multiplication (Row x Col)."
                            ], 
                            "displayName": "01 Matrix Multiplication with OpenCL Kernel", 
                            "key_concepts": [
                                "OpenCL APIs"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "02_local_mem_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is a simple example of matrix multiplication (Row x Col) to demonstrate how to reduce number of memory accesses using local memory."
                            ], 
                            "displayName": "02 Matrix Multiplication with Local Memory", 
                            "key_concepts": [
                                "Kernel Optimization", 
                                "Local Memory"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "03_burst_rw_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is a simple example of matrix multiplication (Row x Col) to demonstrate how to achieve better pipeline with burst read and write to/from local memory from/to DDR."
                            ], 
                            "displayName": "03 Matrix Multiplication Burst Read Write", 
                            "key_concepts": [
                                "Kernel Optimization", 
                                "Burst Read/Write"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "04_partition_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is a simple example of matrix multiplication (Row x Col) to demonstrate how to achieve better performance by array partitioning and loop unrolling."
                            ], 
                            "displayName": "04 Matrix Multiplication Array Partition and Loop Unroll", 
                            "keywords": [
                                "pragma HLS PIPELINE", 
                                "pragma HLS ARRAY_PARTITION complete", 
                                "pragma HLS UNROLL"
                            ], 
                            "key_concepts": [
                                "Array Partition", 
                                "Loop Unroll"
                            ], 
                            "author": "Xilinx"
                        }
                    ]
                }, 
                {
                    "name": "dataflow", 
                    "displayName": [
                        "Dataflow Examples"
                    ], 
                    "description": [
                        "Kernel Optimization through Macro Level Pipelining"
                    ], 
                    "categories": [], 
                    "examples": [
                        {
                            "name": "dataflow_func_ocl", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is simple example of vector addition to demonstrate Dataflow functionality in OpenCL Kernel. OpenCL Dataflow allows user to run multiple functions together to achieve higher throughput."
                            ], 
                            "displayName": "Dataflow Function OpenCL(CL)", 
                            "keywords": [
                                "xcl_dataflow", 
                                "xclDataflowFifoDepth"
                            ], 
                            "key_concepts": [
                                "Function/Task Level Parallelism"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "dataflow_pipes_ocl", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is simple example of vector addition to demonstrate OpenCL Pipe Memory usage. OpenCL PIPE memory functionality allows user to achieve kernel-to-kernel data transfer without using global memory."
                            ], 
                            "displayName": "Blocking Pipes (CL)", 
                            "keywords": [
                                "pipe", 
                                "xcl_reqd_pipe_depth", 
                                "read_pipe_block()", 
                                "write_pipe_block()"
                            ], 
                            "key_concepts": [
                                "Dataflow", 
                                "kernel to kernel pipes"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "dataflow_stream_array_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is simple example of Multiple Stages Vector Addition to demonstrate Array of Stream usage in HLS C Kernel Code."
                            ], 
                            "displayName": "Dataflow Using HLS Stream (C)", 
                            "keywords": [
                                "dataflow", 
                                "hls::stream<>"
                            ], 
                            "key_concepts": [
                                "Array of Stream"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "dataflow_stream_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is simple example of vector addition to demonstrate Dataflow functionality of HLS. HLS Dataflow allows user to schedule multiple task together to achieve higher throughput."
                            ], 
                            "displayName": "Dataflow Using HLS Stream", 
                            "keywords": [
                                "dataflow", 
                                "hls::stream<>"
                            ], 
                            "key_concepts": [
                                "Task Level Parallelism"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "dataflow_subfunc_ocl", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is simple example of vector addition to demonstrate how OpenCL Dataflow allows user to run multiple sub functions together to achieve higher throughput."
                            ], 
                            "displayName": "Dataflow SubFunction OpenCL(CL)", 
                            "keywords": [
                                "xcl_dataflow", 
                                "xclDataflowFifoDepth"
                            ], 
                            "key_concepts": [
                                "SubFunction Level Parallelism"
                            ], 
                            "author": "Xilinx"
                        }
                    ]
                }, 
                {
                    "name": "debug", 
                    "displayName": [
                        "Debug/Profile Examples"
                    ], 
                    "description": [
                        "Debugging and Profiling of Kernel."
                    ], 
                    "categories": [], 
                    "examples": [
                        {
                            "name": "debug_printf_ocl", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is simple example of vector addition and printing of data that is computational result (addition). It is based on vectored addition that demonstrates printing of work item data (integer product in this case)"
                            ], 
                            "displayName": "Printf Usage in Kernel code (CL)", 
                            "keywords": [
                                "printf", 
                                "param:compiler.enableAutoPipelining=false"
                            ], 
                            "key_concepts": [
                                "Use of print statements for debugging"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "debug_profile_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is simple example of vector addition and printing profile data (wall clock time taken between start and stop). It also dump a waveform file which can be reloaded to vivado to see the waveform. Run command 'vivado -source ./scripts/open_waveform.tcl -tclargs <device_name>-<kernel_name>.<target>.<device_name>.wdb' to launch waveform viewer. User can also update batch to gui in sdaccel.ini file to see the live waveform while running application."
                            ], 
                            "displayName": " Printing Profile Data and Dumping Waveform file (C)", 
                            "key_concepts": [
                                "Use of Profile API", 
                                "Waveform Dumping and loading"
                            ], 
                            "author": "Xilinx"
                        }
                    ]
                }, 
                {
                    "name": "hello_world", 
                    "displayName": [
                        "Hello World Examples"
                    ], 
                    "description": [
                        "Hello World examples for new users"
                    ], 
                    "categories": [], 
                    "examples": [
                        {
                            "name": "helloworld_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is simple example of vector addition to describe how to use HLS kernels in Sdx Environment. This example highlights the concepts like PIPELINE which increases the kernel performance "
                            ], 
                            "displayName": "Hello World (HLS C/C++ Kernel)", 
                            "keywords": [
                                "gmem", 
                                "bundle", 
                                "#pragma HLS INTERFACE", 
                                "m_axi", 
                                "s_axi4lite"
                            ], 
                            "key_concepts": [
                                "HLS C Kernel", 
                                "OpenCL Host APIs"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "helloworld_ocl", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This example is a simple OpenCL application. It will highlight the basic flow of an OpenCL application."
                            ], 
                            "displayName": "Hello World (CL)", 
                            "key_concepts": [
                                "OpenCL API"
                            ], 
                            "author": "Xilinx"
                        }
                    ]
                }, 
                {
                    "name": "host", 
                    "displayName": [
                        "Host Examples"
                    ], 
                    "description": [
                        "OpenCL host code for optimized interfacing with Xilinx Devices"
                    ], 
                    "categories": [], 
                    "examples": [
                        {
                            "name": "concurrent_kernel_execution_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This example will demonstrate how to use multiple and out of order command queues to simultaneously execute multiple kernels on an FPGA."
                            ], 
                            "displayName": "Concurrent Kernel Execution (C)", 
                            "keywords": [
                                "CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE", 
                                "clSetEventCallback()"
                            ], 
                            "key_concepts": [
                                "Concurrent execution", 
                                "Out of Order Command Queues", 
                                "Multiple Command Queues"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "copy_buffer_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This Copy Buffer example demonstrate how one buffer can be copied from another buffer."
                            ], 
                            "displayName": "Copy Buffer (C)", 
                            "keywords": [
                                "cl::CommandQueue::enqueueCopyBuffer()"
                            ], 
                            "key_concepts": [
                                "Copy Buffer"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "data_transfer_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This example illustrates several ways to use the OpenCL API to transfer data to and from the FPGA"
                            ], 
                            "displayName": "Data Transfer (C)", 
                            "keywords": [
                                "enqueueWriteBuffer()", 
                                "enqueueReadBuffer()", 
                                "enqueueMapBuffer()", 
                                "enqueueUnmapMemObject()", 
                                "enqueueMigrateMemObjects()"
                            ], 
                            "key_concepts": [
                                "OpenCL API", 
                                "Data Transfer", 
                                "Write Buffers", 
                                "Read Buffers", 
                                "Map Buffers", 
                                "Async Memcpy"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "device_query_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This example prints the OpenCL properties of the platform and its devices. It also displays the limits and capabilities of the hardware."
                            ], 
                            "displayName": "Device Query (C)", 
                            "keywords": [
                                "clGetPlatformIDs()", 
                                "clGetPlatformInfo()", 
                                "clGetDeviceIDs()", 
                                "clGetDeviceInfo()"
                            ], 
                            "key_concepts": [
                                "OpenCL API", 
                                "Querying device properties"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "device_query_cpp", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This Example prints the OpenCL properties of the platform and its devices using OpenCL CPP APIs. It also displays the limits and capabilities of the hardware."
                            ], 
                            "displayName": "Device Query (CPP)", 
                            "key_concepts": [
                                "OpenCL API", 
                                "Querying device properties"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "errors_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This example discuss the different reasons for errors in OpenCL and how to handle them at runtime."
                            ], 
                            "displayName": "Error Handling (C)", 
                            "keywords": [
                                "CL_SUCCESS", 
                                "CL_DEVICE_NOT_FOUND", 
                                "CL_DEVICE_NOT_AVAILABLE"
                            ], 
                            "key_concepts": [
                                "OpenCL API", 
                                "Error handling"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "errors_cpp", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This example discuss the different reasons for errors in OpenCL C++ and how to handle them at runtime."
                            ], 
                            "displayName": "Error Handling (CPP)", 
                            "keywords": [
                                "CL_SUCCESS", 
                                "CL_DEVICE_NOT_FOUND", 
                                "CL_DEVICE_NOT_AVAILABLE", 
                                "CL_INVALID_VALUE", 
                                "CL_INVALID_KERNEL_NAME", 
                                "CL_INVALID_BUFFER_SIZE"
                            ], 
                            "key_concepts": [
                                "OpenCL C++ API", 
                                "Error handling"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "hbm_bandwidth", 
                            "commit_id": "2ea0641ef1c5ff6a2d1ddc44c021f22b8a081f13", 
                            "description": [
                                "This is a HBM bandwidth check design. Design contains 8 compute units of a kernel which has access to all HBM banks (0:31). Host application allocate buffer into all HBM banks and run these 8 compute units concurrently and measure the overall bandwidth between Kernel and HBM Memory."
                            ], 
                            "displayName": "HBM Bandwidth", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "hbm_simple", 
                            "commit_id": "2ea0641ef1c5ff6a2d1ddc44c021f22b8a081f13", 
                            "description": [
                                "This is a simple example of vector addition to describe how to use HLS kernels with HBM (High Bandwidth Memory) for achieving high throughput."
                            ], 
                            "displayName": "HBM Simple Vector Addition", 
                            "keywords": [
                                "HBM", 
                                "XCL_MEM_TOPOLOGY", 
                                "cl_mem_ext_ptr_t"
                            ], 
                            "key_concepts": [
                                "High Bandwidth Memory", 
                                "Multiple HBM Banks"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "host_global_bandwidth", 
                            "commit_id": "2ea0641ef1c5ff6a2d1ddc44c021f22b8a081f13", 
                            "description": [
                                "Host to global memory bandwidth test"
                            ], 
                            "displayName": "host_global", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "host_global_bandwidth_5.0_shell", 
                            "commit_id": "2ea0641ef1c5ff6a2d1ddc44c021f22b8a081f13", 
                            "description": [
                                "Host to global memory bandwidth test for 5.0 shell"
                            ], 
                            "displayName": "host_global_5.0_shell", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "kernel_swap_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This example shows how host can swap the kernels and share same buffer between two kernels which are exist in separate binary containers. Dynamic platforms does not persist the buffer data so host has to migrate data from device to host memory before swapping the next kernel. After kernel swap, host has to migrate the buffer back to device."
                            ], 
                            "displayName": "Vector Add - Vector Multiplication for XPR Devices", 
                            "keywords": [
                                "clEnqueueMigrateMemObjects()", 
                                "CL_MIGRATE_MEM_OBJECT_HOST"
                            ], 
                            "key_concepts": [
                                "Handling Buffer sharing across multiple binaries", 
                                "Multiple Kernel Binaries"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "multiple_devices_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This example show how to take advantage of multiple FPGAs on a system. It will show how to initialized an OpenCL context, allocate memory on the two devices and execute a kernel on each FPGA."
                            ], 
                            "displayName": "Multiple FPGA Devices Execution Concurrently (C)", 
                            "keywords": [
                                "cl_device_id", 
                                "clGetDeviceIDs()"
                            ], 
                            "key_concepts": [
                                "OpenCL API", 
                                "Multi-FPGA Execution", 
                                "Event Handling"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "multiple_process_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This example will demonstrate how to run multiple processes to utilize multiple kernels simultaneously on an FPGA device. Multiple processes can share access to the same device provided each process uses the same xclbin. Processes share access to all device resources but there is no support for exclusive access to resources by any process."
                            ], 
                            "displayName": "Multiple Process (C)", 
                            "keywords": [
                                "PID", 
                                "fork", 
                                "XCL_MULTIPROCESS_MODE", 
                                "multiprocess"
                            ], 
                            "key_concepts": [
                                "Concurrent execution", 
                                "Multiple HLS kernels", 
                                "Multiple Process Support"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "overlap_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This examples demonstrates techniques that allow user to overlap Host(CPU) and FPGA computation in an application. It will cover asynchronous operations and event object."
                            ], 
                            "displayName": "Overlap Host and HLS kernels (C)", 
                            "keywords": [
                                "cl_event", 
                                "clCreateCommandQueue", 
                                "CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE", 
                                "clEnqueueMigrateMemObjects"
                            ], 
                            "key_concepts": [
                                "OpenCL API", 
                                "Synchronize Host and FPGA", 
                                "Asynchronous Processing", 
                                "Events", 
                                "Asynchronous memcpy"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "stream_access_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is a simple example that demonstrates on how to process an input stream of data for computation in an application. It shows how to perform asynchronous operations and event handling."
                            ], 
                            "displayName": "Stream Access (C)", 
                            "keywords": [
                                "cl::event", 
                                "CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE"
                            ], 
                            "key_concepts": [
                                "OpenCL API", 
                                "Synchronize Host and FPGA", 
                                "Asynchronous Processing", 
                                "Events", 
                                "Asynchronous Data Transfer"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "sub_devices_c", 
                            "commit_id": "2ea0641ef1c5ff6a2d1ddc44c021f22b8a081f13", 
                            "description": [
                                "This example demonstrates how to create OpenCL subdevices which uses a single kernel multiple times in order to show how to handle each instance independently including independent buffers, command queues and sequencing."
                            ], 
                            "displayName": "Sub Devices (C)", 
                            "keywords": [
                                "cl_device_partition_property", 
                                "createSubDevices", 
                                "CL_DEVICE_PARTITION_EQUALLY"
                            ], 
                            "key_concepts": [
                                "Sub Devices"
                            ], 
                            "author": "Xilinx"
                        }
                    ]
                }, 
                {
                    "name": "kernel_opt", 
                    "displayName": [
                        "Kernel Optimization Examples"
                    ], 
                    "description": [
                        "Kernel Optimization for performance"
                    ], 
                    "categories": [], 
                    "examples": [
                        {
                            "name": "aos_vs_soa_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This example demonstrates how data layout can impact the performance of certain kernels. The example we will demonstrate how using the Structure of Array data layout can impact certain data parallel problems."
                            ], 
                            "displayName": "Array of Structure(AoS) vs Structure of Arrays(SoA) (C)", 
                            "key_concepts": [
                                "Kernel Optimization", 
                                "Data Layout"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "array_partition_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is a simple example of matrix multiplication (Row x Col) to demonstrate how to achieve better performance by array partitioning, using HLS kernel in SDx Environment."
                            ], 
                            "displayName": "Array Partition (HLS C/C++ Kernel)", 
                            "keywords": [
                                "#pragma HLS ARRAY_PARTITION", 
                                "complete"
                            ], 
                            "key_concepts": [
                                "Kernel Optimization", 
                                "HLS C Kernel", 
                                "Array Partition"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "array_partition_ocl", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This example shows how to use array partitioning to improve performance of a kernel"
                            ], 
                            "displayName": "Array Partitioning (CL)", 
                            "keywords": [
                                "xcl_array_partition", 
                                "complete"
                            ], 
                            "key_concepts": [
                                "Kernel Optimization", 
                                "Array Partitioning"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "dependence_inter_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This Example demonstrates the HLS pragma 'DEPENDENCE'.Using 'DEPENDENCE' pragma, user can provide additional dependency details to the compiler by specifying if the dependency in consecutive loop iterations on buffer is true/false, which allows the compiler to perform unrolling/pipelining to get better performance."
                            ], 
                            "displayName": "Loop Iteration Dependency (C)", 
                            "keywords": [
                                "DEPENDENCE", 
                                "inter", 
                                "WAR"
                            ], 
                            "key_concepts": [
                                "Inter Dependence"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "lmem_2rw_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is simple example of vector addition to demonstrate how to utilized both ports of Local Memory memory."
                            ], 
                            "displayName": "Two Parallel Read/Write on Local Memory (C)", 
                            "keywords": [
                                "#pragma HLS UNROLL FACTOR=2"
                            ], 
                            "key_concepts": [
                                "Kernel Optimization", 
                                "2port BRAM Utilization", 
                                "two read/write Local Memory"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "lmem_2rw_ocl", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is simple example of vector addition to demonstrate how to utilized both ports of Local Memory."
                            ], 
                            "displayName": "Two Parallel Read/Write on Local Memory (CL)", 
                            "keywords": [
                                "opencl_unroll_hint(2)"
                            ], 
                            "key_concepts": [
                                "Kernel Optimization", 
                                "2port BRAM Utilization", 
                                "two read/write Local Memory"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "loop_fusion_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This example will demonstrate how to fuse two loops into one to improve the performance of an OpenCL  C/C++ Kernel."
                            ], 
                            "displayName": "Loop Fusion (C)", 
                            "keywords": [
                                "#pragma HLS PIPELINE"
                            ], 
                            "key_concepts": [
                                "Kernel Optimization", 
                                "Loop Fusion", 
                                "Loop Pipelining"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "loop_fusion_ocl", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This example will demonstrate how to fuse two loops into one to improve the performance of an OpenCL kernel."
                            ], 
                            "displayName": "Loop Fusion (CL)", 
                            "keywords": [
                                "xcl_pipeline_loop"
                            ], 
                            "key_concepts": [
                                "Kernel Optimization", 
                                "Loop Fusion", 
                                "Loop Pipelining"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "loop_pipeline_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This example demonstrates how loop pipelining can be used to improve the performance of a kernel."
                            ], 
                            "displayName": "Loop Pipelining (C)", 
                            "keywords": [
                                "pragma HLS PIPELINE"
                            ], 
                            "key_concepts": [
                                "Kernel Optimization", 
                                "Loop Pipelining"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "loop_reorder_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is a simple example of matrix multiplication (Row x Col) to demonstrate how to achieve better pipeline II factor by loop reordering."
                            ], 
                            "displayName": "Loop Reorder for better Performance(C)", 
                            "keywords": [
                                "#pragma HLS PIPELINE", 
                                "#pragma HLS ARRAY_PARTITION"
                            ], 
                            "key_concepts": [
                                "Kernel Optimization", 
                                "Loop reorder to improve II"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "loop_reorder_ocl", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is a simple example of matrix multiplication (Row x Col) to demonstrate how to achieve better pipeline II factor by loop reordering."
                            ], 
                            "displayName": "Loop Reorder for better Performance(CL)", 
                            "keywords": [
                                "xcl_pipeline_loop", 
                                "xcl_array_partition(complete, 2)"
                            ], 
                            "key_concepts": [
                                "Kernel Optimization", 
                                "Loop reorder to improve II"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "partition_cyclicblock_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This example shows how to use array block and cyclic partitioning to improve performance of a kernel"
                            ], 
                            "displayName": "Array Block and Cyclic Partitioning (C)", 
                            "keywords": [
                                "#pragma HLS ARRAY_PARTITION", 
                                "cyclic", 
                                "block", 
                                "factor", 
                                "dim"
                            ], 
                            "key_concepts": [
                                "Kernel Optimization", 
                                "Array Partitioning", 
                                "Block Partition", 
                                "Cyclic Partition"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "partition_cyclicblock_ocl", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This example shows how to use array block and cyclic partitioning to improve performance of a kernel"
                            ], 
                            "displayName": "Array Block and Cyclic Partitioning (CL)", 
                            "keywords": [
                                "xcl_array_partition", 
                                "cyclic", 
                                "block"
                            ], 
                            "key_concepts": [
                                "Kernel Optimization", 
                                "Array Partitioning", 
                                "Block Partition", 
                                "Cyclic Partition"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "shift_register_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This example demonstrates how to shift values in registers in each clock cycle"
                            ], 
                            "displayName": "Shift Register (C)", 
                            "keywords": [
                                "#pragma HLS ARRAY_PARTITION"
                            ], 
                            "key_concepts": [
                                "Kernel Optimization", 
                                "Shift Register", 
                                "FIR"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "shift_register_ocl", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This example demonstrates how to shift values in registers in each clock cycle"
                            ], 
                            "displayName": "Shift Register (CL)", 
                            "keywords": [
                                "xcl_array_partition", 
                                "getprofilingInfo()"
                            ], 
                            "key_concepts": [
                                "Kernel Optimization", 
                                "Shift Register", 
                                "FIR"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "sum_scan_ocl", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is a simple example to explain the usage of pipeline and array partitioning for designing parallel prefix sum "
                            ], 
                            "displayName": "Parallel Prefix Sum (CL)", 
                            "keywords": [
                                "xcl_array_partition", 
                                "xcl_pipeline_loop"
                            ], 
                            "key_concepts": [
                                "Kernel Optimization", 
                                "Array Partitioning", 
                                "Pipeline"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "systolic_array_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is a simple example of matrix multiplication (Row x Col) to help developers learn systolic array based algorithm design. Note : Systolic array based algorithm design is well suited for FPGA."
                            ], 
                            "displayName": "Systolic Array Implementation (C)", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "systolic_array_ocl", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is a simple example of matrix multiplication (Row x Col) to help developers learn systolic array based algorithm design. Note: Systolic array based algorithm design is well suited for FPGA."
                            ], 
                            "displayName": "Systolic Array Implementation (CL)", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "vectorization_memorycoalescing_ocl", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This example is a simple OpenCL application which highlights the vectorization concept. It provides a basis for calculating the bandwidth utilization when the compiler looking to vectorize."
                            ], 
                            "displayName": "Vectorization (CL)", 
                            "keywords": [
                                "vec_type_hint"
                            ], 
                            "key_concepts": [
                                "Vectorization", 
                                "Memory Coalescing"
                            ], 
                            "author": "Xilinx"
                        }
                    ]
                }, 
                {
                    "name": "kernel_to_gmem", 
                    "displayName": [
                        "Kernel To Global Memory Examples"
                    ], 
                    "description": [
                        "Kernel to Global Memory Access Optimization."
                    ], 
                    "categories": [], 
                    "examples": [
                        {
                            "name": "burst_rw_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is simple example of using AXI4-master interface for burst read and write"
                            ], 
                            "displayName": "Burst Read/Write (C)", 
                            "keywords": [
                                "memcpy", 
                                "max_read_burst_length", 
                                "max_write_burst_length"
                            ], 
                            "key_concepts": [
                                "burst access"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "burst_rw_ocl", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is simple example of using AXI4-master interface for burst read and write"
                            ], 
                            "displayName": "Burst Read/Write (CL)", 
                            "keywords": [
                                "param:compiler.interfaceWrBurstLen", 
                                "param:compiler.interfaceRdBurstLen"
                            ], 
                            "key_concepts": [
                                "burst access"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "custom_datatype_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is simple example of RGB to HSV conversion to demonstrate Custom DATA Type usages in C Based Kernel. Xilinx HLS Compiler Supports Custom Data Type to use for operation as well as Memory Interface between Kernel and Global Memory."
                            ], 
                            "displayName": "Custom Data Type (C)", 
                            "keywords": [
                                "struct", 
                                "#pragma HLS data_pack", 
                                "#pragma HLS LOOP_TRIPCOUNT"
                            ], 
                            "key_concepts": [
                                "Custom Datatype"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "full_array_2d_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is a simple example of accessing full data from 2d array"
                            ], 
                            "displayName": "Full 2D Array Read/Write (C)", 
                            "key_concepts": [
                                "2D data full array Access"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "full_array_2d_ocl", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is a simple example of accessing full data from 2d array"
                            ], 
                            "displayName": "Full 2D Array Read/Write (CL)", 
                            "key_concepts": [
                                "2D data full array Access"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "gmem_2banks_c", 
                            "commit_id": "2ea0641ef1c5ff6a2d1ddc44c021f22b8a081f13", 
                            "description": [
                                "This example of 2ddr to demonstrate on how to use 2ddr DSA. How to create buffers in each DDR."
                            ], 
                            "displayName": "Global Memory Two Banks (C)", 
                            "keywords": [
                                "max_memory_ports", 
                                "misc:map_connect", 
                                "HLS Interface m_axi bundle"
                            ], 
                            "key_concepts": [
                                "Multiple Banks"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "gmem_2banks_c_5.0_shell", 
                            "commit_id": "2ea0641ef1c5ff6a2d1ddc44c021f22b8a081f13", 
                            "description": [
                                "This example of 2ddr to demonstrate on how to use 2ddr DSA. How to create buffers in each DDR."
                            ], 
                            "displayName": "Global Memory Two Banks (C) for 5.0 shell", 
                            "keywords": [
                                "max_memory_ports", 
                                "misc:map_connect", 
                                "HLS Interface m_axi bundle"
                            ], 
                            "key_concepts": [
                                "Multiple Banks"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "gmem_2banks_ocl", 
                            "commit_id": "2ea0641ef1c5ff6a2d1ddc44c021f22b8a081f13", 
                            "description": [
                                "This example of 2ddr to demonstrate on how to use 2ddr DSA. How to create buffers in each DDR."
                            ], 
                            "displayName": "Global Memory Two Banks (CL)", 
                            "keywords": [
                                "max_memory_ports", 
                                "misc:map_connect"
                            ], 
                            "key_concepts": [
                                "Multiple Banks"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "gmem_2banks_ocl_5.0_shell", 
                            "commit_id": "2ea0641ef1c5ff6a2d1ddc44c021f22b8a081f13", 
                            "description": [
                                "This example of 2ddr to demonstrate on how to use 2ddr DSA. How to create buffers in each DDR."
                            ], 
                            "displayName": "Global Memory Two Banks (CL) for 5.0 shell", 
                            "keywords": [
                                "max_memory_ports", 
                                "misc:map_connect"
                            ], 
                            "key_concepts": [
                                "Multiple Banks"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "kernel_global_bandwidth", 
                            "commit_id": "2ea0641ef1c5ff6a2d1ddc44c021f22b8a081f13", 
                            "description": [
                                "Bandwidth test of global to local memory."
                            ], 
                            "displayName": "kernel_global", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "memcoalesce_hang_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This example shows Memory Coalesce Deadlock/Hand situation and how to handle it. User can switch between BAD and GOOD case using makefile variable KFLOW."
                            ], 
                            "displayName": "Memory Coalesce Deadlock/Hang Handling (C)", 
                            "keywords": [
                                "HLS INTERFACE", 
                                "bundle", 
                                "m_axi"
                            ], 
                            "key_concepts": [
                                "Memory Coalesce", 
                                "Memory Deadlock/Hang", 
                                "Multiple Interfaces"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "plram_access_c", 
                            "commit_id": "2ea0641ef1c5ff6a2d1ddc44c021f22b8a081f13", 
                            "description": [
                                "This example shows the usage of PLRAM and how to use it with simple matrix multiplication (Row x Col)."
                            ], 
                            "displayName": "PLRAM access (C)", 
                            "keywords": [
                                "PLRAM"
                            ], 
                            "key_concepts": [
                                "SDx Memory Hierarchy", 
                                "PLRAMs"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "row_array_2d_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is a simple example of accessing each row of data from 2d array"
                            ], 
                            "displayName": "Read/Write Row of 2D Array (C)", 
                            "keywords": [
                                "hls::stream"
                            ], 
                            "key_concepts": [
                                "Row of 2D data array access"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "row_array_2d_ocl", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is a simple example of accessing each row of data from 2d array"
                            ], 
                            "displayName": "Read/Write Row of 2D Array (CL)", 
                            "keywords": [
                                "xcl_dataflow", 
                                "xcl_pipeline_loop"
                            ], 
                            "key_concepts": [
                                "Row of 2D data array access"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "slr_assign", 
                            "commit_id": "2ea0641ef1c5ff6a2d1ddc44c021f22b8a081f13", 
                            "description": [
                                "This is simple example to describe SLR assignment information for a platform design. This example highlights how to provide extra input to assign the logic of the kernel into a nominated SLR. In this example we are assigning first kernel(Vector Multiplication) to SLR0 and assigning the second kernel(Vector Addition) to SLR1"
                            ], 
                            "displayName": "SLR Assign (CL)", 
                            "keywords": [
                                "slr"
                            ], 
                            "key_concepts": [
                                "SLR Assignments"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "wide_mem_rw_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is simple example of vector addition to demonstrate Wide Memory Access using ap_uint<512> data type. Based on input argument type, xocc compiler will figure our the memory datawidth between Global Memory and Kernel. For this example, ap_uint<512> datatype is used, so Memory datawidth will be 16 x (integer bit size) = 16 x 32 = 512 bit."
                            ], 
                            "displayName": "Wide Memory Read/Write (C)", 
                            "keywords": [
                                "ap_uint<>", 
                                "ap_int.h"
                            ], 
                            "key_concepts": [
                                "Kernel to DDR", 
                                "wide memory access", 
                                "burst read and write"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "wide_mem_rw_ocl", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is simple example of vector addition to demonstrate Wide Memory Access using uint16 data type. Based on input argument type, xocc compiler will figure our the memory datawidth between Global Memory and Kernel. For this example, uint16 datatype is used, so Memory datawidth will be 16 x (integer bit size) = 16 x 32 = 512 bit."
                            ], 
                            "displayName": "Wide Memory Read/Write (CL)", 
                            "keywords": [
                                "uint16", 
                                "xcl_pipeline_loop"
                            ], 
                            "key_concepts": [
                                "Kernel to DDR", 
                                "wide memory access", 
                                "burst read and write"
                            ], 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "window_array_2d_c", 
                            "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                            "description": [
                                "This is a simple example of accessing each window of data from 2d array"
                            ], 
                            "displayName": "Read/Write Window of 2D Array (C)", 
                            "keywords": [
                                "#pragma HLS DATAFLOW", 
                                "#pragma HLS PIPELINE", 
                                "#pragma HLS stream"
                            ], 
                            "key_concepts": [
                                "window of 2D data array access"
                            ], 
                            "author": "Xilinx"
                        }
                    ]
                }
            ], 
            "examples": []
        }, 
        {
            "name": "vision", 
            "displayName": "", 
            "description": "", 
            "categories": [], 
            "examples": [
                {
                    "name": "affine", 
                    "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                    "description": [
                        "Affine transformation is a linear mapping method that preserves points, straight lines, and planes. Sets of parallel lines remain parallel after an affine transformation. The affine transformation technique is typically used to correct for geometric distortions or deformations that occur with non-ideal camera angles. The demo performs a 30 degree X rotation and a 50% X and Y scaling on a 512 by 512, 16 bits per pixels grayscale, raw MRI image."
                    ], 
                    "displayName": "Affine", 
                    "author": "Wakahara Project"
                }, 
                {
                    "name": "convolve", 
                    "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                    "description": [
                        "The convolve example is a performant design which showcases convolutional image filtering. The example processes the image 8 pixels at a time."
                    ], 
                    "displayName": "Convolve", 
                    "author": "Xilinx"
                }, 
                {
                    "name": "edge_detection", 
                    "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                    "description": [
                        "Implementation of a Sobel Filter for edge detection."
                    ], 
                    "displayName": "Edge Detection", 
                    "author": "Xilinx"
                }, 
                {
                    "name": "histogram_eq", 
                    "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                    "description": [
                        "This is an optimized implementation of a 12-bit histogram equalizer targeting execution on an SDAccel supported FPGA acceleration card."
                    ], 
                    "displayName": "Histogram Equalization", 
                    "author": "Xilinx"
                }, 
                {
                    "name": "huffman_codec", 
                    "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                    "description": [
                        "This is an implementation of a huffman encoding/decoding algorithm targeting execution on an SDAccel supported FPGA acceleration card."
                    ], 
                    "displayName": "Huffman Encoding/Decoding", 
                    "author": "Xilinx"
                }, 
                {
                    "name": "idct", 
                    "commit_id": "2ea0641ef1c5ff6a2d1ddc44c021f22b8a081f13", 
                    "description": [
                        "Example shows an optimized Inverse Discrete Cosine Transfom. Optimizations are applied to the kernel as well as the host code."
                    ], 
                    "displayName": "Inverse Discrete Cosine Transform", 
                    "author": "Xilinx"
                }, 
                {
                    "name": "idct_5.0_shell", 
                    "commit_id": "2ea0641ef1c5ff6a2d1ddc44c021f22b8a081f13", 
                    "description": [
                        "Example shows an optimized Inverse Discrete Cosine Transfom. Optimizations are applied to the kernel as well as the host code."
                    ], 
                    "displayName": "Inverse Discrete Cosine Transform for 5.0 shell", 
                    "author": "Xilinx"
                }, 
                {
                    "name": "median_filter", 
                    "commit_id": "4679ad762c22f4acd541efca41562bdc3b9e4035", 
                    "description": [
                        "This is an optimized implementation of a median filter being used to remove noise in images targeting execution on an SDAccel supported FPGA acceleration card."
                    ], 
                    "displayName": "Median Filter", 
                    "author": "Xilinx"
                }, 
                {
                    "name": "watermarking", 
                    "commit_id": "2ea0641ef1c5ff6a2d1ddc44c021f22b8a081f13", 
                    "description": [
                        "This is an optimized implementation of a watermarking application to add watermarking to images targeting execution on an SDAccel supported FPGA acceleration card."
                    ], 
                    "displayName": "Watermarking", 
                    "author": "Xilinx"
                }, 
                {
                    "name": "watermarking_5.0_shell", 
                    "commit_id": "2ea0641ef1c5ff6a2d1ddc44c021f22b8a081f13", 
                    "description": [
                        "This is an optimized implementation of a watermarking application to add watermarking to images targeting execution on an SDAccel supported FPGA acceleration card."
                    ], 
                    "displayName": "Watermarking for 5.0 shell", 
                    "author": "Xilinx"
                }
            ]
        }
    ], 
    "examples": [], 
    "branch": "2018.3"
